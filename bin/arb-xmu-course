#!/usr/bin/env ruby
require 'slop'
require 'httpclient'
require 'terminal-table'

require 'json'
require 'arb/xmu/course'

include Arb::Util
include Arb::Xmu::Course

TOKEN_FILE_NAME = 'encrypted_token'
TOKEN_SEPARATOR = ':'
CLIENT = HTTPClient.new

opts = Slop.parse do |o|
  o.bool *%w{-h --help}, '显示帮助'
  o.bool *%w{-c --clear}, '清除本地账户信息'
  o.bool *%w{-r --reset}, '重置账户信息'

  #院选课程 xxlx=4
  o.bool *%w{-s --school}, '院选选课模式'
  #校选课程 xxlx=3
  o.bool *%w{-g --general}, '校选选课模式'
  #公共课程 xxlx=5
  o.bool *%w{-p --public}, '公共课选课模式'

  o.bool *%w{-v --version}, '显示当前版本'
end

case true
  when opts.version?
    puts Arb::Xmu::Course::VERSION
  when opts.help?
    puts(opts) && exit
  when opts.clear?
    File.delete(TOKEN_FILE_NAME) && exit
  when opts.reset?
    set_up_account
  when opts.school?
    select_school_elective(CLIENT)
  when opts.general?
    select_general_elective(CLIENT)
  when opts.public?
    select_public(CLIENT)
  else
    puts(opts) && exit
end

def select_school_elective(client)
  select_course_common client, 'http://bkxk.xmu.edu.cn/xsxk/yxxx.html?pagination=5000', 4
end

def select_general_elective(client)
  select_course_common client, 'http://bkxk.xmu.edu.cn/xsxk/qxxxx.html?pagination=5000', 3
end

def select_public(client)
  select_course_common client, 'http://bkxk.xmu.edu.cn/xsxk/ggk.html?pagination=5000', 5
end

def select_course_common(client, url, xxlx)
  prepare_select_course(client)
  courses = parse_courses((client.get url).body)
  show_courses_in_table courses
  try_to_select_courses(client, courses, xxlx, get_main_select_round(client))
  $stdout.puts '已经开始选课，输入字符q退出。'
  loop do
    exit if 'q'==$stdin.gets.chomp
  end
end

def set_up_account
  $stdout.puts '请输入学号：'
  stu_id= $stdin.gets.chomp
  $stdout.puts '请输入密码：'
  passwd= $stdin.gets.chomp
  File.open TOKEN_FILE_NAME, 'w' do |file|
    file.write (SimpleDes.encrypt(stu_id)+TOKEN_SEPARATOR+SimpleDes.encrypt(passwd))
  end
  $stdout.puts '账号信息已经加密并保存在当前目录，请妥善保管。'
  exit
end

def retrieve_check_code(client)
  File.open 'check_code.jpeg', 'wb' do |file|
    file.write(client.get('http://bkxk.xmu.edu.cn/xsxk/getCheckCode').body)
  end
  $stdout.puts '验证码图片已在当前目录生成，请查看后输入：'
  $stdin.gets.chomp
end

def authorize_session(client, username, password)
  client.get 'http://bkxk.xmu.edu.cn/xsxk/login.html', username: username, password: password, checkCode: retrieve_check_code(client)
  #握手选课系统
  client.get 'http://bkxk.xmu.edu.cn/xsxk/localInfo.html'
  client.get 'http://bkxk.xmu.edu.cn/xsxk/index.html'
end

#获取选课轮次
def get_select_round(client, id)
  round_id=nil
  client.get('http://bkxk.xmu.edu.cn/xsxk/index.html').body.scan /addXklcList\((.*?)\)/m do |match|
    tmp_arr = filter_text(match[0].split(','))
    if tmp_arr[2]==id.to_s
      round_id=tmp_arr[1]
      break
    end
  end
  round_id
end

#获取主修选课轮次
def get_main_select_round(client)
  get_select_round(client, 1)
end

def show_courses_in_table(courses)
  table = Terminal::Table.new do |table|
    table.add_row %w{ID 课程名称 学分 班号 主讲老师 总学时}
    courses.each do |course_entity|
      table.add_separator
      table.add_row course_entity.to_a
    end
  end
  $stdout.puts table
end

def parse_courses(raw_html)
  courses = []
  count=0
  transform_bracket(raw_html).scan /top\.createJxbObj\((.*?)\)/m do |match|
    tmp_arr = filter_text(match[0].split(','))
    courses << CourseEntity.new do |entity|
      entity.index= (count=count+1)
      entity.id= tmp_arr[1]
      entity.name= tmp_arr[4]
      entity.credit= tmp_arr[10]
      entity.teacher= tmp_arr[14]
      entity.period= tmp_arr[8]
      entity.class_name= tmp_arr[5]
    end
  end
  courses.select { |course| course.id.size>0 }
end

def create_attempt_thread(max_interval, client, course, xxlx, lcid, &block)
  Thread.new do
    count=0
    loop do
      count+=1
      interval= 1+rand(max_interval)
      sleep interval
      res = request_select_course(client, course, xxlx, lcid)
      if res['success']
        $stdout.puts '', "《#{course.name}》（#{course.class_name}班）已经成功选课！", ''
        break
      else
        $stdout.puts '', "《#{course.name}》（#{course.class_name}班）第#{count}次尝试选课失败，#{interval}秒后将重试。（#{filter_text(res['message'])}）", ''
      end
    end
    exit if block.binding.local_variable_get(:opened_thread_count)-1==0
  end
end

def request_select_course(client, course_entity, xxlx, lcid)
  msg = client.get 'http://bkxk.xmu.edu.cn/xsxk/elect.html',
                   method: 'handleZxxk',
                   jxbid: course_entity.id,
                   xxlx: xxlx,
                   xklc: lcid
  JSON::parse msg.body
end

def prepare_select_course(client)
  ensure_local_account
  username, password = get_account_info
  authorize_session(client, username, password)
end

def process_ids(str_ids)
  #return int_ids
  int_ids = str_ids.map do |item|
    next item.to_i unless item=~/[^0-9]/
    next (Range.new *(item.split('-').map(&:to_i))).to_a if item.include? '-'
  end
  int_ids.flatten.uniq
end

def try_to_select_courses(client, courses, xxlx, lcid)
  $stdout.puts '', '输入要选的课程ID（重复无效，支持语法糖：x-y，会尝试选择ID从x到y的所有课程）， 以空格分割：'
  ids = process_ids($stdin.gets.chomp.split(' '))
  $stdout.puts '输入最大重试间隔时间，要求不得低于3秒：'
  max_interval = $stdin.gets.chomp.to_i
  max_interval = 3 if max_interval<3
  opened_thread_count = ids.size
  ids.each do |id|
    create_attempt_thread(max_interval, client, courses.find { |course| course.index==id }, xxlx, lcid) {}
  end
end

def get_account_info
  stu_id, passwd=nil
  File.open TOKEN_FILE_NAME, 'r' do |file|
    stu_id, passwd=SimpleDes.decrypt(file.read.split(TOKEN_SEPARATOR))
  end
  [stu_id, passwd]
rescue
  puts '账号信息受损，请重新设置：'
  set_up_account
end

def ensure_local_account
  unless File.exists? TOKEN_FILE_NAME
    puts '请先设置账号信息（账号信息会先加密然后保存在本地，用于授权选课系统）'
    set_up_account && exit
  end
end

#转换圆括号
def transform_bracket(raw)
  if Enumerable===raw
    return [].tap do |arr|
      raw.each do |item|
        arr<<transform_bracket(item)
      end
    end
  end
  raw.gsub! /\((.*)\)/ do |match|
    "（#{match[1..-2]}）"
  end
  raw
end
def filter_text(raw)
  if Enumerable===raw
    return [].tap do |arr|
      raw.each do |item|
        arr<<filter_text(item)
      end
    end
  end
  black_list =([] << "\r" << "\n" << "\t" << "'" << '<br>')
  black_list.each do |tmp|
    raw.gsub! tmp, ''
  end
  raw
end